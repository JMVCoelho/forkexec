package com.forkexec.pts.ws.cli;

import static javax.xml.ws.BindingProvider.ENDPOINT_ADDRESS_PROPERTY;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

import java.util.regex.Pattern;

import javax.xml.ws.BindingProvider;
import javax.xml.ws.Response;

import com.forkexec.pts.ws.cli.exception.BadInitFault_Exception;
import com.forkexec.pts.ws.cli.exception.EmailAlreadyExistsFault_Exception;
import com.forkexec.pts.ws.cli.exception.InvalidEmailFault_Exception;
import com.forkexec.pts.ws.cli.exception.InvalidPointsFault_Exception;
import com.forkexec.pts.ws.cli.exception.NotEnoughBalanceFault_Exception;
import com.forkexec.pts.ws.cli.exception.BadInitFault;
import com.forkexec.pts.ws.cli.exception.EmailAlreadyExistsFault;
import com.forkexec.pts.ws.cli.exception.InvalidEmailFault;
import com.forkexec.pts.ws.cli.exception.InvalidPointsFault;
import com.forkexec.pts.ws.cli.exception.NotEnoughBalanceFault;
import com.forkexec.pts.ws.PointsPortType;
import com.forkexec.pts.ws.PointsService;
import com.forkexec.pts.ws.ReadResponse;
import com.forkexec.pts.ws.WriteResponse;
import com.forkexec.pts.ws.CtrlClearResponse;
import com.forkexec.pts.ws.CtrlInitResponse;
import com.forkexec.pts.ws.CtrlPingResponse;
import com.forkexec.pts.ws.DoesUserExist;
import com.forkexec.pts.ws.DoesUserExistResponse;
import com.forkexec.pts.ws.Account;

import pt.ulisboa.tecnico.sdis.ws.uddi.UDDINaming;

/**
 * Client port wrapper.
 *
 * Adds easier end point address configuration to the Port generated by
 * wsimport.
 */
public class PointsClient /* implements PointsPortType */ {
	private int caso; // ignore this - necessary for the demonstration

	private int nReplicas;

	private int QCneed;

	// AtomicInteger responseCount = new AtomicInteger(0);

	// private CopyOnWriteArrayList<Account> quorumAccounts;

	// private CopyOnWriteArrayList<String> quorumPings;

	// private CopyOnWriteArrayList<Boolean> quorumExists;

	// private ArrayList<PointsPortType> replicas = null;

	private final int CACHE_SIZE = 5;

	private ConcurrentHashMap<String, CashedBalance> cacheLRU = new ConcurrentHashMap<String, CashedBalance>(
			CACHE_SIZE);

	private long currIteration = 0;

	private ReentrantLock operationsQueue = new ReentrantLock();

	/** WS service */
	PointsService service = null;

	/** WS port (port type is the interface, port is the implementation) */
	PointsPortType port = null;

	/** UDDI server URL */
	private String uddiURL = null;

	/** WS name */
	private String wsName = null;

	/** WS replicas names */
	// Collection<String> replicasWsURL = null;

	/** WS end point address */
	private String wsURL = null; // default value is defined inside WSDL

	public String getWsURL() {
		return wsURL;
	}

	/** output option **/
	private boolean verbose = false;

	public boolean isVerbose() {
		return verbose;
	}

	public void setVerbose(boolean verbose) {
		this.verbose = verbose;
	}

	/** constructor with provided web service URL */
	public PointsClient(String wsURL) throws PointsClientException {
		this.wsURL = wsURL;
		// createStub();
	}

	/** constructor with provided UDDI location and name */
	public PointsClient(String uddiURL, String wsName, int nReplicas, int caso) throws PointsClientException {
		// ignore variable caso: it's necessary for the demonstration!
		this.uddiURL = uddiURL;
		this.wsName = wsName;
		this.nReplicas = nReplicas;
		this.QCneed = nReplicas / 2 + 1;
		this.caso = caso;
		/*
		 * uddiLookup(replicasWsURL); createStub(replicasWsURL);
		 */
	}

	/** UDDI lookup */
	private Collection<String> uddiLookup() throws PointsClientException {
		Collection<String> replicasWsURL;
		try {
			if (verbose)
				System.out.printf("Contacting UDDI at %s%n", uddiURL);
			UDDINaming uddiNaming = new UDDINaming(uddiURL);

			if (verbose)
				System.out.printf("Looking for '%s'%n", wsName);

			replicasWsURL = uddiNaming.list(wsName + "%");
			// wsURL = uddiNaming.lookup(wsName);

		} catch (Exception e) {
			String msg = String.format("Client failed lookup on UDDI at %s!", uddiURL);
			throw new PointsClientException(msg, e);
		}

		if (replicasWsURL == null) {
			String msg = String.format("Service with name %s not found on UDDI at %s", wsName, uddiURL);
			throw new PointsClientException(msg);
		}
		return replicasWsURL;
	}

	/** Stub creation and configuration */
	private void createStub(Collection<String> replicasWsURL, CopyOnWriteArrayList<PointsPortType> replicas) {
		for (String current_wsURL : replicasWsURL) {
			wsURL = current_wsURL;
			if (verbose)
				System.out.println("Creating stub ...");
			service = new PointsService();
			port = service.getPointsPort();

			replicas.add(port);

			if (wsURL != null) {
				if (verbose)
					System.out.println("Setting endpoint address ...");
				BindingProvider bindingProvider = (BindingProvider) port;
				Map<String, Object> requestContext = bindingProvider.getRequestContext();
				requestContext.put(ENDPOINT_ADDRESS_PROPERTY, wsURL);
			}
		}
	}

	// Main operations ----------------------------------------------

	/** Email address validation. */
	private void checkValidEmail(final String emailAddress) throws InvalidEmailFault_Exception {
		final String message;
		if (emailAddress == null) {
			message = "Null email is not valid";
		} else if (!Pattern.matches("(\\w\\.?)*\\w+@\\w+(\\.?\\w)*", emailAddress)) {
			message = String.format("Email: %s is not valid", emailAddress);
		} else {
			return;
		}
		throwInvalidEmailFault(message);
	}

	public void activateUser(String userEmail) throws InvalidEmailFault_Exception, EmailAlreadyExistsFault_Exception {
		checkValidEmail(userEmail);

		if (doesUserExist(userEmail))
			throwEmailAlreadyExistsFault("email ja esta em uso");
		getAccount(userEmail, true);

		return;
	}

	public int pointsBalance(String userEmail) throws InvalidEmailFault_Exception {
		checkValidEmail(userEmail);

		Account acc = getAccount(userEmail, true);

		return acc.getPoints();
	}

	public int addPoints(String userEmail, int pointsToAdd)
			throws InvalidPointsFault_Exception, InvalidEmailFault_Exception {
		checkValidEmail(userEmail);
		if (pointsToAdd <= 0) {
			throwInvalidPointsFault("cannot add negative points");
		}
		operationsQueue.lock();
		Account acc = getAccount(userEmail, false);
		acc.setTag(acc.getTag() + 1);
		acc.setPoints(acc.getPoints() + pointsToAdd);

		setAccount(acc);
		operationsQueue.unlock();

		return acc.getPoints();
	}

	public int spendPoints(String userEmail, int pointsToSpend)
			throws InvalidEmailFault_Exception, NotEnoughBalanceFault_Exception, InvalidPointsFault_Exception {
		checkValidEmail(userEmail);
		if (pointsToSpend <= 0) {
			throwInvalidPointsFault("cannot spend negative points");
		}
		operationsQueue.lock();
		Account acc = getAccount(userEmail, false);
		if (acc.getPoints() - pointsToSpend < 0) {
			throwNotEnoughBalanceFault("not enough balance");
		}
		acc.setTag(acc.getTag() + 1);
		acc.setPoints(acc.getPoints() - pointsToSpend);
		setAccount(acc);
		operationsQueue.unlock();
		return acc.getPoints();
	}

	// control operations -----------------------------------------------------

	public String ctrlPing(String inputMessage) {

		ArrayList<String> pings = ctrlPingQuorum(inputMessage);
		System.out.println("received " + pings.size() + " pings");

		return pings.get(0);
	}

	public void ctrlClear() {

		ctrlClearQuorum();
		resetCache();

	}

	public void ctrlInit(int startPoints) throws BadInitFault_Exception {
		if (startPoints < 0) {
			throwBadInit("an account cannot start with negative points");
		}

		ctrlInitQuorum(startPoints);

	}

	private Account getAccount(String userEmail, boolean saveToCache) {
		Account acc = readFromCache(userEmail);
		if (acc == null) {
			acc = readQuorum(userEmail);
		}
		if (saveToCache == true) {
			writeToCache(acc);
		}
		return acc;
	}

	private void setAccount(Account acc) {
		writeQuorum(acc);
		writeToCache(acc);
	}

	// cache methods ----------------------------------------------------------

	private Account readFromCache(final String userEmail) {
		if (cacheLRU.containsKey(userEmail)) {
			CashedBalance cachedB = cacheLRU.get(userEmail);
			Account acc = new Account();
			acc.setTag(cachedB.getTag());
			acc.setPoints(cachedB.getPoints());
			acc.setUserEmail(userEmail);
			return acc;
		}
		return null;
	}

	private void writeToCache(final Account acc) {
		currIteration++;
		long minIteration = Long.MAX_VALUE;
		String minIterationKey = null;
		// if cache has the position already, updates it
		if (cacheLRU.containsKey(acc.getUserEmail())) {
			CashedBalance cachedB = cacheLRU.get(acc.getUserEmail());
			cachedB.setTag(acc.getTag());
			cachedB.setPoints(acc.getPoints());
			cachedB.setIteration(currIteration);

		}
		// else needs to add to the cache
		else {
			// if cache is full, remove an element (LRU)
			if (cacheLRU.size() == CACHE_SIZE) {
				for (String userE : cacheLRU.keySet()) {
					if (minIteration > cacheLRU.get(userE).getIteration()) {
						minIteration = cacheLRU.get(userE).getIteration();
						minIterationKey = userE;
					}
				}
				cacheLRU.remove(minIterationKey);
			}
			cacheLRU.put(acc.getUserEmail(), new CashedBalance(acc.getTag(), acc.getPoints(), currIteration));
		}

	}

	public void printCache() {
		for (String userEmail : cacheLRU.keySet()) {
			CashedBalance cBalance = cacheLRU.get(userEmail);
			System.out.println(userEmail + " : " + cBalance.getPoints() + " - " + cBalance.getTag() + " (LRU: "
					+ cBalance.getIteration() + ")");
		}
	}

	private void resetCache() {
		cacheLRU.clear();
	}

	// remote invocation methods ----------------------------------------------

	private boolean doesUserExist(String userEmail) {
		try {
			// update servers up
			Collection<String> replicasWsURL = null;
			CopyOnWriteArrayList<PointsPortType> replicas = new CopyOnWriteArrayList<>();
			replicasWsURL = uddiLookup();
			createStub(replicasWsURL, replicas);

			CopyOnWriteArrayList<Boolean> quorumExists = new CopyOnWriteArrayList<>();
			AtomicInteger responseCount = new AtomicInteger(0);

			for (PointsPortType currPort : replicas) {
				DoesUserExistThread reader = new DoesUserExistThread(currPort, userEmail, quorumExists, responseCount);
				Thread thread = new Thread(reader);
				thread.start();
			}

			while (responseCount.get() < QCneed) {
				Thread.sleep(10);
			}

			for (Boolean answer : quorumExists) {
				if (answer.booleanValue() == true)
					return true;
			}

		} catch (PointsClientException e) {
			e.printStackTrace();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		return false;
	}

	public class DoesUserExistThread implements Runnable {
		private PointsPortType myPort;
		private String myEmail;
		CopyOnWriteArrayList<Boolean> quorumExists;
		AtomicInteger responseCount;

		public DoesUserExistThread(final PointsPortType currPort, final String currEmail,
				CopyOnWriteArrayList<Boolean> quorumExists, AtomicInteger responseCount) {
			this.myPort = currPort;
			this.myEmail = currEmail;
			this.quorumExists = quorumExists;
			this.responseCount = responseCount;
		}

		@Override
		public void run() {
			Response<DoesUserExistResponse> myResponse = myPort.doesUserExistAsync(this.myEmail);
			try {
				while (!myResponse.isDone() && responseCount.get() < QCneed) {
					Thread.sleep(200);
				}
				if (responseCount.get() < QCneed) {
					quorumExists.add((new Boolean(myResponse.get().isReturn())));
					responseCount.getAndIncrement();
				}
				return;
			} catch (ExecutionException e) {
				e.printStackTrace();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	private Account readQuorum(String userEmail) {
		Account mostRecentAccount = null;
		try {
			// update servers up
			Collection<String> replicasWsURL = null;
			CopyOnWriteArrayList<PointsPortType> replicas = new CopyOnWriteArrayList<>();
			if (caso == 2) {
				System.out.println("STOP POINT - If posible turn a server up");
				System.out.println("You have 8 seconds.");
				Thread.sleep(8000);
			}

			replicasWsURL = uddiLookup();
			createStub(replicasWsURL, replicas);

			if (caso == 2) {
				System.out.println("STOP POINT - If posible shutdown a server");
				System.out.println("You have 8 seconds.");
				Thread.sleep(8000);
			}

			CopyOnWriteArrayList<Account> quorumAccounts = new CopyOnWriteArrayList<>();
			AtomicInteger responseCount = new AtomicInteger(0);

			for (PointsPortType currPort : replicas) {
				ReaderThread reader = new ReaderThread(currPort, userEmail, quorumAccounts, responseCount);
				Thread thread = new Thread(reader);
				thread.start();
			}

			while (responseCount.get() < QCneed) {
				Thread.sleep(10);
			}

			long maxTag = -1;
			for (Account currAccount : quorumAccounts) {
				long currTag = currAccount.getTag();
				if (currTag > maxTag) {
					maxTag = currTag;
					mostRecentAccount = currAccount;
				}

			}

		} catch (PointsClientException e) {
			// e.printStackTrace();
		} catch (InterruptedException e) {
			// e.printStackTrace();
		}
		return mostRecentAccount;
	}

	public class ReaderThread implements Runnable {
		private PointsPortType myPort;
		private String myEmail;
		private CopyOnWriteArrayList<Account> quorumAccounts;
		private AtomicInteger responseCount;

		public ReaderThread(final PointsPortType currPort, final String currEmail,
				CopyOnWriteArrayList<Account> quorumAccounts, AtomicInteger responseCount) {
			this.myPort = currPort;
			this.myEmail = currEmail;
			this.quorumAccounts = quorumAccounts;
			this.responseCount = responseCount;
		}

		@Override
		public void run() {
			Response<ReadResponse> myResponse = myPort.readAsync(this.myEmail);
			try {
				while (!myResponse.isDone() && responseCount.get() < QCneed) {
					Thread.sleep(200);
				}
				if (responseCount.get() < QCneed) {
					quorumAccounts.add(myResponse.get().getReturn());
					responseCount.getAndIncrement();
				}
				return;
			} catch (InterruptedException e) {
				System.out.println("FAULT");
				return;
			} catch (ExecutionException e) {
				System.out.println("FAULT");
				return;
			}
		}
	}

	private void writeQuorum(Account currAccount) {
		// update servers up
		try {
			Collection<String> replicasWsURL = null;
			CopyOnWriteArrayList<PointsPortType> replicas = new CopyOnWriteArrayList<>();
			replicasWsURL = uddiLookup();
			createStub(replicasWsURL, replicas);
			AtomicInteger responseCount = new AtomicInteger(0);
			for (PointsPortType currPort : replicas) {
				WriterThread writer = new WriterThread(currPort, currAccount, responseCount);
				Thread thread = new Thread(writer);
				thread.start();
			}
		} catch (PointsClientException e) {
			e.printStackTrace();
		}
	}

	public class WriterThread implements Runnable {
		private PointsPortType myPort;
		private Account myAccount;
		private AtomicInteger responseCount;

		public WriterThread(final PointsPortType currPort, final Account currAccount, AtomicInteger responseCount) {
			this.myPort = currPort;
			this.myAccount = currAccount;
			this.responseCount = responseCount;
		}

		@Override
		public void run() {
			Response<WriteResponse> myResponse = myPort.writeAsync(myAccount);
			try {
				while (!myResponse.isDone() && responseCount.get() < QCneed) {
					Thread.sleep(200);
				}
				if (responseCount.get() < QCneed) {
					responseCount.getAndIncrement();
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}

		}
	}

	private void ctrlClearQuorum() {
		// update servers up
		try {
			Collection<String> replicasWsURL = null;
			CopyOnWriteArrayList<PointsPortType> replicas = new CopyOnWriteArrayList<>();
			replicasWsURL = uddiLookup();
			createStub(replicasWsURL, replicas);
			AtomicInteger responseCount = new AtomicInteger(0);
			for (PointsPortType currPort : replicas) {
				CtrlClearThread writer = new CtrlClearThread(currPort, responseCount);
				Thread thread = new Thread(writer);
				thread.start();
			}
		} catch (PointsClientException e) {
			e.printStackTrace();
		}
	}

	public class CtrlClearThread implements Runnable {
		private PointsPortType myPort;
		private AtomicInteger responseCount;

		public CtrlClearThread(final PointsPortType currPort, AtomicInteger responseCount) {
			this.myPort = currPort;
			this.responseCount = responseCount;
		}

		@Override
		public void run() {
			try {
				Response<CtrlClearResponse> myResponse = myPort.ctrlClearAsync();
				while (!myResponse.isDone() && responseCount.get() < nReplicas) {
					Thread.sleep(200);
				}
				if (responseCount.get() < nReplicas) {
					responseCount.getAndIncrement();
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	private void ctrlInitQuorum(int startPoints) {
		// update servers up
		try {
			Collection<String> replicasWsURL = null;
			CopyOnWriteArrayList<PointsPortType> replicas = new CopyOnWriteArrayList<>();
			replicasWsURL = uddiLookup();
			createStub(replicasWsURL, replicas);
			AtomicInteger responseCount = new AtomicInteger(0);
			for (PointsPortType currPort : replicas) {
				CtrlInitThread writer = new CtrlInitThread(currPort, startPoints, responseCount);
				Thread thread = new Thread(writer);
				thread.start();
			}
		} catch (PointsClientException e) {
			e.printStackTrace();
		}
	}

	public class CtrlInitThread implements Runnable {
		private PointsPortType myPort;
		private int startPoints;
		private AtomicInteger responseCount;

		public CtrlInitThread(final PointsPortType currPort, final int startPoints, AtomicInteger responseCount) {
			this.myPort = currPort;
			this.startPoints = startPoints;
			this.responseCount = responseCount;
		}

		@Override
		public void run() {
			try {
				Response<CtrlInitResponse> myResponse = myPort.ctrlInitAsync(startPoints);
				while (!myResponse.isDone() && responseCount.get() < nReplicas) {
					Thread.sleep(200);
				}
				if (responseCount.get() < nReplicas) {
					responseCount.getAndIncrement();
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	private ArrayList<String> ctrlPingQuorum(String msg) {
		ArrayList<String> pingList = new ArrayList<>();
		try {
			// update servers up
			Collection<String> replicasWsURL = null;
			CopyOnWriteArrayList<PointsPortType> replicas = new CopyOnWriteArrayList<>();
			replicasWsURL = uddiLookup();
			createStub(replicasWsURL, replicas);

			CopyOnWriteArrayList<String> quorumPings = new CopyOnWriteArrayList<>();
			AtomicInteger responseCount = new AtomicInteger(0);

			for (PointsPortType currPort : replicas) {
				CtrlPingThread reader = new CtrlPingThread(currPort, msg, quorumPings, responseCount);
				Thread thread = new Thread(reader);
				thread.start();
			}

			while (responseCount.get() < QCneed) {
				Thread.sleep(10);
			}
			for (String ping : quorumPings) {
				pingList.add(ping);

			}
		} catch (PointsClientException e) {
			e.printStackTrace();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		return pingList;
	}

	public class CtrlPingThread implements Runnable {
		private PointsPortType myPort;
		private String msg;
		private CopyOnWriteArrayList<String> quorumPings;
		private AtomicInteger responseCount;

		public CtrlPingThread(final PointsPortType currPort, final String msg, CopyOnWriteArrayList<String> quorumPings,
				AtomicInteger responseCount) {
			this.myPort = currPort;
			this.msg = msg;
			this.quorumPings = quorumPings;
			this.responseCount = responseCount;
		}

		@Override
		public void run() {
			Response<CtrlPingResponse> myResponse = myPort.ctrlPingAsync(this.msg);
			try {
				while (!myResponse.isDone() && responseCount.get() < QCneed) {
					Thread.sleep(200);
				}

				if (responseCount.get() < QCneed) {
					quorumPings.add(myResponse.get().getReturn());
					responseCount.getAndIncrement();
				}
				return;
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (ExecutionException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}
	}

	// Exception helpers
	private void throwBadInit(final String message) throws BadInitFault_Exception {
		final BadInitFault faultInfo = new BadInitFault();
		faultInfo.setMessage(message);
		throw new BadInitFault_Exception(message, faultInfo);
	}

	private void throwEmailAlreadyExistsFault(final String message) throws EmailAlreadyExistsFault_Exception {
		final EmailAlreadyExistsFault faultInfo = new EmailAlreadyExistsFault();
		faultInfo.setMessage(message);
		throw new EmailAlreadyExistsFault_Exception(message, faultInfo);
	}

	private void throwInvalidEmailFault(final String message) throws InvalidEmailFault_Exception {
		final InvalidEmailFault faultInfo = new InvalidEmailFault();
		faultInfo.setMessage(message);
		throw new InvalidEmailFault_Exception(message, faultInfo);
	}

	private void throwNotEnoughBalanceFault(final String message) throws NotEnoughBalanceFault_Exception {
		final NotEnoughBalanceFault faultInfo = new NotEnoughBalanceFault();
		faultInfo.setMessage(message);
		throw new NotEnoughBalanceFault_Exception(message, faultInfo);
	}

	private void throwInvalidPointsFault(final String message) throws InvalidPointsFault_Exception {
		final InvalidPointsFault faultInfo = new InvalidPointsFault();
		faultInfo.setMessage(message);
		throw new InvalidPointsFault_Exception(message, faultInfo);
	}

}
